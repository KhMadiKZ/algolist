<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0074)file:///E:/olymp/books/unsorted/e-maxx(MAXimal)/e-maxx(new)/euler_path.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>MAXimal :: algo :: Нахождение Эйлерова пути или Эйлерова цикла</title><link rel="stylesheet" type="text/css" href="./MAXimal    algo    Нахождение Эйлерова пути или Эйлерова цикла_files/style.css" tppabs="http://e-maxx.ru/data/style.css"><link rel="stylesheet" type="text/css" href="./MAXimal    algo    Нахождение Эйлерова пути или Эйлерова цикла_files/geshi.css" tppabs="http://e-maxx.ru/geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class="main" cellpadding="0" cellspacing="0"><tbody><tr><td class="title" colspan="2"><p>MAXimal</p></td></tr><tr><td class="menu"><ul><li><a href="javascript:if(confirm('http://e-maxx.ru/index.php  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://e-maxx.ru/index.php'" tppabs="http://e-maxx.ru/index.php">home</a></li><li><a href="file:///E:/olymp/books/unsorted/e-maxx(MAXimal)/e-maxx(new)/index.htm" tppabs="http://e-maxx.ru/algo/" class="current">algo</a></li><li><a href="javascript:if(confirm('http://e-maxx.ru/wiki/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://e-maxx.ru/wiki/'" tppabs="http://e-maxx.ru/wiki/">wiki</a></li><li><a href="javascript:if(confirm('http://e-maxx.ru/bookz/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://e-maxx.ru/bookz/'" tppabs="http://e-maxx.ru/bookz/">bookz</a></li><li><a href="javascript:if(confirm('http://e-maxx.ru/forum/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://e-maxx.ru/forum/'" tppabs="http://e-maxx.ru/forum/">forum</a></li><li><a href="javascript:if(confirm('http://e-maxx.ru/about.php  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://e-maxx.ru/about.php'" tppabs="http://e-maxx.ru/about.php">about</a></li></ul></td><td class="content"><p class="algoinfo">прочитано: 5684 раз<br>добавлено: 10 Jun 2008 22:14<br>редактировано: 10 Jun 2008 22:15</p><h1>Нахождение Эйлерова пути за O (M)</h1>

<p>Эйлеров путь - это путь в графе, проходящий через все его рёбра. Эйлеров цикл - это эйлеров путь, являющийся циклом.</p>
<p>Задача заключается в том, чтобы найти эйлеров путь в <b>неориентированном мультиграфе с петлями</b>.</p>
<h2>Алгоритм</h2>
<p>Сначала проверим, существует ли эйлеров путь. Затем найдём все простые циклы и объединим их в один - это и будет эйлеровым циклом. Если граф таков, что эйлеров путь не является циклом, то, добавим недостающее ребро, найдём эйлеров цикл, потом удалим лишнее ребро.</p>
<p>Чтобы проверить, существует ли эйлеров путь, нужно воспользоваться следующей теоремой. Эйлеров цикл существует тогда и только тогда, когда степени всех вершин чётны. Эйлеров путь существует тогда и только тогда, когда количество вершин с нечётными степенями равно двум (или нулю, в случае существования эйлерова цикла).</p>
<p>Кроме того, конечно, граф должен быть достаточно связным (т.е. если удалить из него все изолированные вершины, то должен получиться связный граф).</p>
<p>Искать все циклы и объединять их будем одной рекурсивной процедурой:</p>
<pre>procedure FindEulerPath (V)
	1. перебрать все рёбра, выходящие из вершины V;
		каждое такое ребро удаляем из графа, и
		вызываем FindEulerPath из второго конца этого ребра;
	2. добавляем вершину V в ответ.</pre>
<p>Сложность этого алгоритма, очевидно, является линейной относительно числа рёбер.</p>
<p>Но этот же алгоритм мы можем записать в <b>нерекурсивном</b> варианте:</p>
<pre>stack St;
в St кладём любую вершину (стартовая вершина);
пока St не пустой
	пусть V - значение на вершине St;
	если степень(V) = 0, то
		добавляем V к ответу;
		снимаем V с вершины St;
	иначе
		находим любое ребро, выходящее из V;
		удаляем его из графа;
		второй конец этого ребра кладём в St;
</pre>
<p>Несложно проверить эквивалентность этих двух форм алгоритма. Однако вторая форма, очевидно, быстрее работает, причём кода будет не больше.</p>
<h2>Задача о домино</h2>
<p>Приведём здесь классическую задачу на эйлеров цикл - задачу о домино.</p>
<p>Имеется N доминошек, как известно, на двух концах доминошки записано по одному числу (обычно от 1 до 6, но в нашем случае не важно). Требуется выложить все доминошки в ряд так, чтобы у любых двух соседних доминошек числа, записанные на их общей стороне, совпадали. Доминошки разрешается переворачивать.</p>
<p>Переформулируем задачу. Пусть числа, записанные на донимошках, - вершины графа, а доминошки - рёбра этого графа (каждая доминошка с числами (a,b) - это ребра (a,b) и (b,a)). Тогда наша задача <b>сводится к</b> задаче нахождения <b>эйлерова пути</b> в этом графе.</p>
<h2>Реализация</h2>
<p>Приведенная ниже программа ищет и выводит эйлеров цикл или путь в графе, или выводит -1, если его не существует.</p>
<p>Сначала программа проверяет степени вершин: если вершин с нечётной степенью нет, то в графе есть эйлеров цикл, если есть 2 вершины с нечётной степенью, то в графе есть только эйлеров путь (эйлерова цикла нет), если же таких вершин больше 2, то в графе нет ни эйлерова цикла, ни эйлерова пути. Чтобы найти эйлеров путь (не цикл), поступим таким образом: если V1 и V2 - это две вершины нечётной степени, то просто добавим ребро (V1,V2), в полученном графе найдём эйлеров цикл (он, очевидно, будет существовать), а затем удалим из ответа "фиктивное" ребро (V1,V2). Эйлеров цикл будем искать в точности так, как описано выше (нерекурсивной версией), и заодно по окончании этого алгоритма проверим, связный был граф или нет (если граф был не связный, то по окончании работы алгоритма в графе останутся некоторые рёбра, и в этом случае нам надо вывести -1). Наконец, программа учитывает, что в графе могут быть изолированные вершины.</p>
<pre>int main() {

	int n;
	vector &lt; vector&lt;int&gt; &gt; g (n, vector&lt;int&gt; (n));
	... чтение графа в матрицу смежности ...

	vector&lt;int&gt; deg (n);
	for (int i=0; i&lt;n; ++i)
		for (int j=0; j&lt;n; ++j)
			deg[i] += g[i][j];

	int first = 0;
	while (!deg[first])  ++first;

	int v1 = -1,  v2 = -1;
	bool bad = false;
	for (int i=0; i&lt;n; ++i)
		if (deg[i] &amp; 1)
			if (v1 == -1)
				v1 = i;
			else if (v2 == -1)
				v2 = i;
			else
				bad = true;

	if (v1 != -1)
		++g[v1][v2],  ++g[v2][v1];

	stack&lt;int&gt; st;
	st.push (first);
	vector&lt;int&gt; res;
	while (!st.empty())
	{
		int v = st.top();
		int i;
		for (i=0; i&lt;n; ++i)
			if (g[v][i])
				break;
		if (i == n)
		{
			res.push_back (v);
			st.pop();
		}
		else
		{
			--g[v][i];
			--g[i][v];
			st.push (i);
		}
	}

	if (v1 != -1)
		for (size_t i=0; i+1&lt;res.size(); ++i)
			if (res[i] == v1 &amp;&amp; res[i+1] == v2 || res[i] == v2 &amp;&amp; res[i+1] == v1)
			{
				vector&lt;int&gt; res2;
				for (size_t j=i+1; j&lt;res.size(); ++j)
					res2.push_back (res[j]);
				for (size_t j=1; j&lt;=i; ++j)
					res2.push_back (res[j]);
				res = res2;
				break;
			}

	for (int i=0; i&lt;n; ++i)
		for (int j=0; j&lt;n; ++j)
			if (g[i][j])
				bad = true;

	if (bad)
		puts ("-1");
	else
		for (size_t i=0; i&lt;res.size(); ++i)
			printf ("%d ", res[i]+1);

}</pre></td></tr></tbody></table><table width="100%"><tbody><tr><td><p style="text-align:center;"><img src="./MAXimal    algo    Нахождение Эйлерова пути или Эйлерова цикла_files/valid-html401-blue.png" tppabs="http://www.w3.org/Icons/valid-html401-blue" alt="Valid HTML 4.01 Strict" height="31" width="88"><img src="./MAXimal    algo    Нахождение Эйлерова пути или Эйлерова цикла_files/valid-css2-blue.png" tppabs="http://www.w3.org/Icons/valid-css2-blue" alt="Valid CSS 2.1" height="31" width="88"></p></td></tr></tbody></table></body></html>